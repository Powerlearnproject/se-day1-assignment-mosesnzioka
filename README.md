[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-2e0aaae1b6195c2367325f4f02e2d04e9abb55f0b24a779b69b11b9e10269abc.svg)](https://classroom.github.com/online_ide?assignment_repo_id=18411634&assignment_repo_type=AssignmentRepo)
# SE_Day1
Software Engineering Day1 Assignment

#Part 1: Introduction to Software Engineering

## Q1.
Explain what software engineering is and discuss its importance in the technology industry.
Software engineering is the process of designing, building, testing, and maintaining software. It is a branch of computer science that uses engineering principles to create software that meets user needs

### Importance of sofware engineering in Technology industry

1. bulding high quality software
. Ensures software in reliable, secure and scelable through structured design and rigorius testing to reduce bugs

2. Scelability and Mentainerbility
. A well designed software can be easly updated and expanded to accomodate growth

3. Security and Data protection
. Helps in bulding secure application that protects user data and cyber threats.


## Q2.
Identify and describe at least three key milestones in the evolution of software engineering.
#### The birth of Software Engineering
NATO Software Engineering Conference where they recongnized software development as an engineering despline.

Before 1968, software development was considered an ad-hoc process without structured methodologies. However, as software complexity grew, projects often faced delays, cost overruns, and failures—this became known as the "Software Crisis."

To address these challenges, NATO organized a conference in 1968 where the term "software engineering" was first introduced. This milestone led to:

Adoption of structured programming and formal development methodologies.
Increased focus on software reliability and maintainability.
Recognition of software as an engineering discipline rather than just coding.

## Q3.
List and briefly explain the phases of the Software Development Life Cycle.
1. Planning
Defines project scope, feasibility, and resource allocation

It involves:-
. Gathering Requrements from the stakeholders
. Indetifying project goals, Risks and constrains
. Determines Budget, Timeline and team role

2. Requrements analysis
Document functional and Non-functional software requrements
. This defines what the software is going to do (features, security, performance)
. Involves discation with stakeholders, business analyst and Developers.
. Outputs software requrements specification document.

3. Design
creates system architecture and Technical blueprint
. Defines software structure, database design, and UI/UX
. Specifies tools, programming languages, and frameworks to be used
. Outputs Software Design Document (SDD) for development reference

4. Development
Write and implement code based on design specifications.

. Developers write code using programming languages and frameworks
. Follows coding standards and best practices
. Uses version control systems (e.g., Git) to track changes

5. Testing
Identify and fix bugs to ensure software reliability.

. Includes unit testing, integration testing, system testing, and user acceptance testing (UAT)
. Automated and manual testing ensures software meets requirements
. Detects security vulnerabilities and performance issues

6. Deployment
Release software to production for users

. Software is installed on servers or cloud platforms
. Uses Continuous Integration/Continuous Deployment (CI/CD) pipelines for smooth deployment
. May involve beta testing before full release.

7. Maintenance & Support
Ensure software remains functional and up-to-date.
. Fixes bugs and security vulnerabilities.
. Adds new features based on user feedback.
.Provides technical support and updates.
## Q4.
Compare and contrast the Waterfall and Agile methodologies. Provide examples of scenarios where each would be appropriate.
. Waterfall methodology uses a linear and sequetial aproach while Agile methodology uses a iterative and incremental aproach.
. Waterfall methodology rigid with fixed requirements while Agile methodology is flexible and it adapts changes.
. In waterfall methodology each phase must be done before moving to the next phase while in Agile methodology work is devided in to cycles(speints) with continuos interaction.
. when using waterfall methodology there is minimal client interaction while in Agile methodology there is high intweraction and imediet feedback to the client.
. High risk as issues are discoverd later while in Agile methodology there is low risk as the issues are addresed early.
. Waterfall methodology takes time as the final product is deliverd at the end while in Agile methodology takes shorter time becouse if one part done is released.
. Waterfall methodology aproach testing is done at the end of the project while in Agile methodology testing is done after every phase.

Best scenario for waterfall methodology:-
Waterfall is ideal for projects with well-defined requirements and little expected change.
Example of this is:-
. Healthcare Systems 
Medical systems require strict adherence to regulations.
. Banking and Financial Systems
High security and stability requirements


Best scenario for Agile methodology:-
Agile is suitable for dynamic projects where requirements evolve over time
The best case use:-
. Startup Product Development
Fast iterations are needed to test and refine the product.
Constant customer feedback is critical for market fit
. E-commerce and Web Applications
Features need frequent updates based on user behavior.

## Q5.
Describe the roles and responsibilities of a Software Developer, a Quality Assurance Engineer, and a Project Manager in a software engineering team.
1. Software Developer
. Designs, writes, and maintains code based on project requirements.
. Implements features, fixes bugs, and optimizes performance.
. Works with databases, APIs, and front-end or back-end technologies.
. Collaborates with other team members, including designers and testers.

2. Quality Assuarance Engineer
. Ensures the software meets quality standards before release.
. Designs and executes test cases (manual and automated).
. Identifies, documents, and tracks bugs.
. Works closely with developers to resolve defects

3. Project Manager
. Oversees project planning, execution, and delivery.
. Coordinates between different teams and stakeholders.
. Ensures the project stays on schedule and within budget.
. Manages risks, expectations, and communication.

## Q6.
Discuss the importance of Integrated Development Environments (IDEs) and Version Control Systems (VCS) in the software development process. Give examples of each.

Importance of Intergrated Development Environment (IDEs)
. Provide tools for writing, debugging, and testing code efficiently.
. Offer features like syntax highlighting, code completion, and debugging.
 Example:
 . Visual Studio Code (VS Code) – lightweight and extensible.

Importance of Version Control Systems (VCS)
. Track changes in code, enabling collaboration and rollback.
. Ensure code history and contributions are managed effectively.
 Example:
 . Git (with GitHub, GitLab, or Bitbucket) – most popular VCS.
 . Subversion (SVN) – centralized version control system.

## Q7.
What are some common challenges faced by software engineers? Provide strategies to overcome these challenges.
. Handling Changing Requirements
   .Solution: Use Agile methodologies for flexibility and continuous feedback.

. Debugging and Fixing Bugs
   .Solution: Implement logging, unit tests, and automated testing.

. Managing Technical Debt
   .Solution: Refactor code regularly and follow coding best practices.

. Keeping Up with New Technologies
   .Solution: Continuous learning through courses, documentation, and projects.

. Collaboration and Communication
  .Solution: Use collaboration tools like Slack, Jira, and Git for code reviews.

## Q8.
Explain the different types of testing (unit, integration, system, and acceptance) and their importance in software quality assurance.
1. Unit Testing
   . Tests individual components or functions.
   . Ensures each unit works as expected.
   . Example: Testing a function that calculates user discounts.
2. Integration Testing
   . Tests interactions between different modules or services.
   . Ensures data flows correctly across components.
   . Example: Verifying API calls between frontend and backend.
3. System Testing
   . Tests the entire application as a whole.
   . Checks for performance, security, and reliability.
   . Example: Ensuring an e-commerce website handles high traffic loads.
4. Acceptance Testing
   . Validates if the software meets business and user requirements.
   . Often conducted by stakeholders before release.
   . Example: User testing a banking app before launch.


#Part 2: Introduction to AI and Prompt Engineering

## Q1.
Define prompt engineering and discuss its importance in interacting with AI models.
. Prompt engineering is the practice of designing effective inputs (prompts) to optimize AI model  responses. It is essential for:

   . Improving AI-generated content quality.
   . Ensuring accurate and relevant responses.
   . Enhancing AI usability across various applications (chatbots, automation, etc.).

## Q2.
Provide an example of a vague prompt and then improve it by making it clear, specific, and concise. Explain why the improved prompt is more effective.
. Vague Prompt:
   "Tell me about space."

.Improved Prompt:
   "Provide a brief overview of the solar system, including the planets and their key characteristics."

Why the Improved Prompt is More Effective:
. More specific – It narrows down the topic to the solar system.
. Concise and clear – It provides explicit expectations.
. Focused output – AI can generate a more structured and relevant response.
